#### 目录介绍
- 01.Widget基础概念
    - 1.1 Widget概念
    - 1.2 Widget骨架
    - 1.3 Widget源码
- 02.StatelessWidget源码
- 03.StatefulWidget源码
- 04.Context是什么作用



### 01.Widget基础概念
#### 1.1 Widget概念
- 在Flutter中几乎所有的对象都是一个Widget。
    - 与原生开发中“控件”不同的是，Flutter中的Widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 `GestureDetector` widget、用于APP主题数据传递的`Theme`等等，而原生开发中的控件通常只是指UI元素。
    - 在描述UI元素时可能会用到“控件”、“组件”这样的概念，读者心里需要知道他们就是widget，只是在不同场景的不同表述而已。
    - 由于Flutter主要就是用于构建用户界面的，所以，在大多数时候，可以认为widget就是一个控件，不必纠结于概念。



#### 1.2 Widget骨架
- Widget 的骨架
    - 常用的 StatefulWidget、StatelessWidget，再加上 (InheritedWidget) 或 ProxyWidget 和 RenderObjectWidget 都继承于 Widget 基类，他们整体构成了 Widget 的骨架。
- 有状态 和 无状态
    - StatelessWidget 无状态的 Widget，常见的子类如 Text、Container。
    - StatefulWidget 有状态的 Widget，常用的子类有 Image、Navigator。
    - ProxyWidget 为代理 Widget，可以快速追溯父节点，通常用来做数据共享，常见的子类 InheritedWidget，各种状态管理框架，如 provider 等正是基于它实现。
    - 什么叫做“状态”？Widget 在 Flutter 架构下设计为不可变的，通常情况下每一帧都会重新构建一个新的 Widget 对象，而无法知道之前的状态。StatefulWidget 通过关联一个 State 对象实现状态的保存。



#### 1.3 Widget源码
- Widget源码如下所示
    ``` dart
    abstract class Widget extends DiagnosticableTree {
      const Widget({ this.key });
    
      final Key key;
    
      @protected
      @factory
      Element createElement();
    
      @override
      String toStringShort() {
        final String type = objectRuntimeType(this, 'Widget');
        return key == null ? type : '$type-$key';
      }
    
      @override
      void debugFillProperties(DiagnosticPropertiesBuilder properties) {
        super.debugFillProperties(properties);
        properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;
      }
    
      @override
      @nonVirtual
      bool operator ==(Object other) => super == other;
    
      @override
      @nonVirtual
      int get hashCode => super.hashCode;
    
      static bool canUpdate(Widget oldWidget, Widget newWidget) {
        return oldWidget.runtimeType == newWidget.runtimeType
            && oldWidget.key == newWidget.key;
      }
    
      static int _debugConcreteSubtype(Widget widget) {
        return widget is StatefulWidget ? 1 :
               widget is StatelessWidget ? 2 :
               0;
        }
    }
    ```
- 主要方法和属性介绍
    - `Widget`类继承自`DiagnosticableTree`，`DiagnosticableTree`即“诊断树”，主要作用是提供调试信息。
    - `Key`: 这个`key`属性类似于React/Vue中的`key`，主要的作用是决定是否在下一次`build`时复用旧的widget，决定的条件在`canUpdate()`方法中。
    - `createElement()`：正如前文所述“一个Widget可以对应多个`Element`”；Flutter Framework在构建UI树时，会先调用此方法生成对应节点的`Element`对象。此方法是Flutter Framework隐式调用的，在我们开发过程中基本不会调用到。
    - `debugFillProperties(...)` 复写父类的方法，主要是设置诊断树的一些特性。
    - `canUpdate(...)`是一个静态方法，它主要用于在Widget树重新`build`时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的`Element`对象的配置；通过其源码我们可以看到，只要`newWidget`与`oldWidget`的`runtimeType`和`key`同时相等时就会用`newWidget`去更新`Element`对象的配置，否则就会创建新的`Element`。
- 核心方法createElement()
    - `Widget`类本身是一个抽象类，其中最核心的就是定义了`createElement()`接口。
    - 在Flutter开发中，我们一般都不用直接继承`Widget`类来实现一个新组件，相反，我们通常会通过继承`StatelessWidget`或`StatefulWidget`来间接继承`Widget`类来实现。
    - `StatelessWidget`和`StatefulWidget`都是直接继承自`Widget`类，而这两个类也正是Flutter中非常重要的两个抽象类，它们引入了两种Widget模型。





### 02.StatelessWidget源码
- StatelessWidget源码如下所示
    ``` dart
    abstract class StatelessWidget extends Widget {
      const StatelessWidget({ Key key }) : super(key: key);
    
      @override
      StatelessElement createElement() => StatelessElement(this);
    
      @protected
      Widget build(BuildContext context);
    }
    ```
- `StatelessWidget`相对比较简单，它继承自`Widget`类，重写了`createElement() `方法。
    - `StatelessElement` 间接继承自`Element`类，与`StatelessWidget`相对应（作为其配置数据）。
- `StatelessWidget`用于不需要维护状态的场景。
    - 它通常在`build`方法中通过嵌套其它Widget来构建UI，在构建过程中会递归的构建其嵌套的Widget。



### 03.StatefulWidget源码
- StatefulWidget源码如下所示
    ``` dart
    abstract class StatefulWidget extends Widget {
      const StatefulWidget({ Key key }) : super(key: key);
    
      @override
      StatefulElement createElement() => StatefulElement(this);
    
      @protected
      @factory
      State createState();
    }
    ```
- `StatefulElement ` 间接继承自`Element`类，与StatefulWidget相对应（作为其配置数据）。
    - `StatefulElement `中可能会多次调用`createState()`来创建状态(State)对象。
- `createState()` 用于创建和Stateful widget相关的状态，它在Stateful widget的生命周期中可能会被多次调用。
    - 例如，当一个Stateful widget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例，其实，本质上就是一个`StatefulElement`对应一个State实例。
- 理解树的概念
    - 在不同的场景可能指不同的意思，在说“widget树”时它可以指widget结构树，但由于widget与Element有对应关系（一可能对多）。
    - 在有些场景（Flutter的SDK文档中）也代指“UI树”的意思。
    - 而在stateful widget中，State对象也和`StatefulElement`具有对应关系（一对一），所以在Flutter的SDK文档中，可以经常看到“从树中移除State对象”或“插入State对象到树中”这样的描述。
    - 其实，无论哪种描述，其意思都是在描述“一棵构成用户界面的节点元素的树”，如果没有特别说明，都可抽象的认为它是“一棵构成用户界面的节点元素的树”。


### 04.Context是什么作用
- 什么是Context
    - `build`方法有一个`context`参数，它是`BuildContext`类的一个实例，表示当前widget在widget树中的上下文，每一个widget都会对应一个context对象（因为每一个widget都是widget树上的一个节点）。
    - 实际上，`context`是当前widget在widget树中位置中执行”相关操作“的一个句柄，比如它提供了从当前widget开始向上遍历widget树以及按照widget类型查找父级widget的方法。
- 下面是在子树中获取父级widget的一个示例：
    ```dart
    class ContextRoute extends StatelessWidget {
      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(
            title: Text("Context测试"),
          ),
          body: Container(
            child: Builder(builder: (context) {
              // 在Widget树中向上查找最近的父级`Scaffold` widget
              Scaffold scaffold = context.findAncestorWidgetOfExactType<Scaffold>();
              // 直接返回 AppBar的title， 此处实际上是Text("Context测试")
              return (scaffold.appBar as AppBar).title;
            }),
          ),
        );
      }
    }
    ```












